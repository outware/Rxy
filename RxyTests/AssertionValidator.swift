
//  Copyright Â© 2018 Derek Clarkson. All rights reserved.

import XCTest
import Nimble

/// Class which is used to track and report on the status of Nimble errors encountered in a closure.
class ErrorLocation {
    
    let error: String
    var expectedFile: StaticString?
    var expectedLine: UInt?
    var foundFile: String?
    var foundLine: Int?
    
    init(error: String, foundInFile file: String, line: Int) {
        self.error = error
        self.foundFile = file
        self.foundLine = line
    }

    init(error: String, expectedInFile file: StaticString, atLine line: UInt?) {
        self.error = error
        self.expectedFile = file
        self.expectedLine = line
    }
    
    func found(inFile file: String, atLine line: Int) {
        self.foundFile = file
        self.foundLine = line
    }

    func `is`(_ error: String) -> Bool {
        return self.error == error
    }
    
    func report(inTestcase testcase: XCTestCase) {
        
        switch (expectedFile, expectedLine, foundFile, foundLine) {

        // Found, expected, but on different line.
        case (.some(let expectedFile), .some(let expectedLine), _, .some(let foundLine)) where expectedLine != foundLine:
            XCTFail("Nimble failure '\(error)' found on line \(foundLine), but expected to be on line \(expectedLine)", file: expectedFile, line: expectedLine)

        case (.none, .none, .some(let foundFile), .some(let foundLine)): // Found, but not expected. Record a failure
            testcase.recordFailure(withDescription: error, inFile: foundFile, atLine: foundLine, expected: true)

        case(.some(let expectedFile), .some(let expectedLine), .none, .none):
            XCTFail("Nimble failure '\(error)' not generated in closure", file: expectedFile, line: expectedLine)

        default:
            // Can't report
            break
        }
    }
}

/// Quick extension that expects an error to be thrown by Nimble.
extension XCTestCase {
    
    /**
     Expected the passed closure to generate an error.
     
     Optionally can also specify the line where the error is expected to be placed by Nimble.
     
     - Parameter file: The test case file. Defaults to #file.
     - Parameter line: The line where this function resides. Defaults to #line.
     - Parameter error: The error text expected to be generated by Nimble.
     - Parameter atLine: Optional line number where the Nimble error is expected to appear.
     - Parameter fromClosure: The closure that is expected to generate the error.
    */
    func expectNimble(file: StaticString = #file, line: UInt = #line, error: String, atLine: UInt? = nil, fromClosure closure: () -> Void) {
        expectNimble(file: file, line: line, errors: [error: (file, atLine)], fromClosure: closure)
    }

    /**
     Expected the passed closure to generate one or more errors.
     
     Optionally can also specify the line where the error is expected to be placed by Nimble.
     
     - Parameter file: The test case file. Defaults to #file.
     - Parameter line: The line where this function resides. Defaults to #line.
     - Parameter errors: A dictionary of error messages and locations which are expected to be generated by Nimble.
     - Parameter fromClosure: The closure that is expected to generate the error.
     */
    func expectNimble(file: StaticString = #file, line: UInt = #line, errors: [String: (StaticString, UInt?)], fromClosure closure: () -> Void) {

        // Create a Nimble error observer and call the closure.
        let expectedErrors = errors.map { ErrorLocation(error: $0.key, expectedInFile: $0.value.0, atLine: $0.value.1) }
        let handler = AssertionValidator(expectedErrors: expectedErrors)
        withAssertionHandler(handler) {
            closure()
        }

        // Only display errors if one or more of the expected errors were not found. Extra errors encountered
        // don't trigger this as we are only interested in showing errors when expected ones are not found.
        if !handler.allErrorsFound {
            handler.errors.forEach { $0.report(inTestcase: self) }
        }
    }
}

/// Implementation of a Nimble AssertionHandler that can be used to capture test failure messages. Note that there is an AssertionRecorder
/// class provided by Nimble that does this, but in this varient we want to ignore all messages if the expected messages are found.
/// This lets us look for specific messages and only display all the messages if one or more are not found.
class AssertionValidator: AssertionHandler {

    private(set) fileprivate var errors:[ErrorLocation] = []
    
    public var allErrorsFound: Bool {
        // If any of the errors don't have a location then it was expected but not found.
        return !errors.contains { $0.foundFile == nil || ($0.expectedLine != nil && $0.foundLine! != $0.expectedLine!) }
    }
    
    init(expectedErrors errors: [ErrorLocation]) {
        self.errors = errors
    }
    
    func assert(_ assertion: Bool, message: FailureMessage, location: SourceLocation) {
        
        // Assertion is true if the Nimble assertion passed.
        if !assertion {
            // Add or set the location of the error.
            if let error = errors.first(where:{ $0.is(message.stringValue) }) {
                error.found(inFile: location.file, atLine: Int(location.line))
            } else {
                errors.append(ErrorLocation(error: message.stringValue, foundInFile: location.file, line: Int(location.line)))
            }
        }
    }
}
