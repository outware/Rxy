#  Rxy - Pragmatic Rx unit testing

Rxy is a bunch of useful functions and classes that can help you to simplify testing of RxSwift based code. It's goal is to provide these features:

* A range of 'wait...' functions that wait for asynchronous RxSwift code to execute then add errors to Xcode's test report if the observable doesn't behave as expected or return the result.
* A range of support functions for building RxSwift based mocks which automatically execute asynchronously so that the mock's threading model matches the implementations.
* A simplified mock configuration model.
* *Significant* code reduction in unit tests.
* *Significant* code reduction in mock classes.

Rxy achieves this through 3 core architectural concepts:

* A set of __waitFor*()__ functions which use the RxBlocking framework to wait on asynchronous Rx calls then provide additional validation of results.
* A set of __*Result__ classes which provide centralised configuration of mock responses.
* A set of __mockFunction(...)__ functions which execute on background threads and post the requested results asynchronously on the main thread.

# Guide

## Mocking

Often we need to mock out the interfaces our Rx code is going to use and often those interfaces return Rx objects. 
So lets deep dive straight into this by looking at a mock for a typical backend service, then refactoring it to use Rxy. Here's the original mock class which provides only 3 functions:

```
class MockHTTPClientOldSchool: HTTPClient {
    
    var postCompletableURL: String?
    var postCompletableURLSuccess: Bool?
    var postCompletableURLError: Error?
    func postCompletable(url: String) -> Completable {
        postCompletableURL = url
        if let _ = postCompletableURLSuccess {
            return Completable.empty()
        }
        if let error = postCompletableURLError {
            return Completable.error(error)
        }
        fatalError("Unexpected method call")
    }
    
    var getSingleURL: String?
    var getSingleURLResult: RemoteCallResponse?
    var getSingleURLError: Error?
    func getSingle(url: String) -> Single<RemoteCallResponse> {
        getSingleURL = url
        if let result = getSingleURLResult {
            return Single.just(result)
        }
        if let error = getSingleURLError {
            return Single.error(error)
        }
        fatalError("Unexpected method call")
    }
    
    var doMaybeURL: String?
    var doMaybeURLComplete: Bool?
    var doMaybeURLResult: RemoteCallResponse?
    var doMaybeURLError: Error?
    func doMaybe(url: String) -> Maybe<RemoteCallResponse> {
        doMaybeURL = url
        if let result = doMaybeURLResult {
            return Maybe.just(result)
        }
        if let _ = doMaybeURLComplete {
            return Maybe.empty()
        }
        if let error = doMaybeURLError {
            return Maybe.error(error)
        }
        fatalError("Unexpected method call")
    }
}
``` 

There are several things of interest in this code:

* The number of variables to provide all the different options for a response to a call.
* All the code required to decide how to respond.
* The fact that it executes synchronously. Although not that important for most unit tests, there are situations where a test can succeed instead of failing because it's running synchronously.

Overall there's quite a bit of code here. Now lets take a look at Rxy's version of this same mock:

```
class MockHTTPClientRxy: BaseMock, HTTPClient {
    
    var postCompletableURL: String?
    var postCompletableURLResult: CompletableResult?
    func postCompletable(url: String) -> Completable {
        postCompletableURL = url
        return mockFunction(returning: postCompletableURLResult)
    }
    
    var getSingleURL: String?
    var getSingleURLResult: SingleResult<RemoteCallResponse>?
    func getSingle(url: String) -> Single<RemoteCallResponse> {
        getSingleURL = url
        return mockFunction(returning: getSingleURLResult)
    }
    
    var doMaybeURL: String?
    var doMaybeURLResult: MaybeResult<RemoteCallResponse>?
    func doMaybe(url: String) -> Maybe<RemoteCallResponse> {
        doMaybeURL = url
        return mockFunction(returning: doMaybeURLResult)
    }
}
``` 

Considerably less code, and it *runs asynchronously*! Here's the core features:

* Inherits from __BaseMock__ - technically not required, however BaseMock tracks the file and line number where the mock was instantiated. This allows Rxy to position errors generated by the mock back in your unit test with any Nimble __expect(…)__ failures. This makes easier debugging because everything is in the same place. So I'd recommend using BaseMock if you can.
* Each function has just one __*Result__ property for defining how it responds. And if you name them consistantly (I recommend the practice of us 'Result' as a suffix) they'll be easy to find.
* All the boilerplate is remove and replaced with __mockFunction(…)__ calls that do all the dirty work.

Thats it. Thats all you need to do to your mocks.


## Unit Testing

## AsyncMock

AsyncMock is an extension that provides functions for asynchronously returning values from mocking that return RxSwift observables.  

When writing mocks for testing, developer usually write code like this:

```
class MyMock: AppProtocol {
    func doSomething() -> Single<AThing> {
        return .just(AThing())
    }
}
```

This executes synhronously and is easy to write, working in the majority of test cases, however there can be sitatuations where synchronous code like this will work in a test, but not work in the app because  

# Installation via Carthage

Add this to your **Cartfile.private** file:

```
github "outware/Rxy"
```